---
title: "All Streams 2014/2016 Parentage"
subtitle: "Hogan + Stockdale + Gilmour + Paddy + Erb"
author: "Kyle Shedd & Kristen Gruenthal"
date: "2 February 2022"
output:
  html_notebook:
    theme: united
    toc: yes
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
###############################################################################
#
# HOW TO USE THIS SCRIPT
# This script has been standardized for ease of use with subsequent parentage, grandparentage, and great granparentage analyses for PINK SALMON
# This script has been re-written and optimized for the "new" GCL-R-Scripts (tibble vs. list) from the `develop` or `master` branch!
# 1. Copy file to correct stream folder in "V:\Analysis\5_Coastwide\Multispecies\Alaska Hatchery Research Program\PWS Pink\GitHub-PWS-Pink-Parentage" and rename
# 2. Replace names, dates, and other information where applicable in script - it is modeled off of "2_Parentage_All_Streams_2014_2016_develop.Rmd"
#    a. Specific terms requiring replacement in the Introduction and below for future use include: 
#      * "all_streams_14_16" (name of parentage objects)
#      * "All_Streams_14_16" (name of "Objects" and "Gentoypes" subdirectories)
#      * years: "2014", "2016", "_14", "_16", "_14_16"
#      * streams: c("Erb", "Paddy", "Hogan", "Gilmour", "Stockdale")
#    b. Please also be sure to update any usernames and passwords, paths, SILLY codes, hatchery designations, and filenames, as well as **Results:** text for the notebook
#    c. This notebook is set up to handle multiple streams, and has some code for multiple generations (F2 +), but please treat anything other than (F0/F1) with caution, since the analysis that this template was based on did not due multi-generational analyses.
# 3. Comment out any sections you do not wish to run (e.g. grandparentage or great grandparentage, if multigenerational data are not available)
#
###############################################################################

rm(list = ls())

# library(kinship2)
library(coin)
library(MASS)
library(scales)
library(tidyverse)
library(leaflet)
library(lubridate)
library(ggExtra)

knitr::opts_chunk$set(out.width = "100%", fig.width = 10)
```

# **Objective**

The objective of this notebook is to combine the parentage/pedigree results from *FRANz* with all paired data (*OceanAK* + *StreamSpecimens* + `riverdist`) to calculate RRS and explore variation in RS. This notebook will produce 5 primary datasets:  

  * `parentage_14_16_filter` - one row per parent-offspring dyad assignment (triads get two rows), only relationships (3 columns)
  * `paired_14_16_filter` - one row per individual (parents and offspring) with all paired data
  * `parents_paired_14_16` - one row per parent-offspring dyad assignment (triads get two rows), with paired data (_off, _par)
  * `paired_14_16_filter_parents` - one row per parent with `n` = number of offspring assigned, and include all potential parents (including those assigned zero offspring)
  * `parents_paired_14_16_cross` - one row per offspring, with both `sire` and `dam` data preserved (_off, _sire, _dam)

# **Background**

## Pedigree reconstruction

We use the program *FRANz* [link](https://www.bioinf.uni-leipzig.de/Software/FRANz/About.html) to reconstruct parent-offspring relationships. Below are analyses of parentage for **all fitness streams (Hogan, Stockdale, Gilmour, Paddy, and Erb)** for the **even lineage** years **2014** (potential parents) and **2016** (potential offspring).

*FRANz* was run by Chase secretly on the UAF cluster on Wed Feb 2 17:54:15 2022 using the following parameters:
FRANz.exe --Nmmax 25000 --Nfmax 25000 --femrepro 1:2 --malerepro 1:2 --typingerror 0.006 --updatefreqs --poutformat 2 All_Streams_14_16_postQA_2014_2016.dat

The parameters are defined as follows:

* --Nmmax and --Nfmax are the maximum numbers of candidate mothers and fathers. To obtain our values, we used an estimated escapement of ~50,000 and divided by 2. This escapement number came from very generously rounding up the maximum population estimate (aerial, stream walk, stream walk corrected for distance surveyed) from each stream. These estimates are listed under in the Excel file found here: [link](V:\Documents\5_Coastwide\Multispecies\AHRP\Field data\Sample Summary Extract and Genotype.xlsx).    
* --femrepro and --malerepro specify the age range in which an individual can reproduce  
* --typingerror refers to the overall genotyping error rate, where ours is usually ~0.5% (can obtained from QC; 0.006 has been used as a default of sorts)
* --updatefreqs specifies that *FRANz* should update allele frequencies using MCMC sampling  
* --poutformat specifies that all potential parents should be listed, not just the most likely  
* --fullsibtest tests for full siblings among offspring   

We do not use --fullsibtest; it won't save output (Kyle's Genetics Domain Computer) or it maxes memory (Kristen's computer).

All output files can also be found here: Output is saved here: [link](V:\Analysis\5_Coastwide\Multispecies\Alaska Hatchery Research Program\PWS Pink/Franz\All_Streams_14_16_develop\results). The summary file provides information about the power of our marker suite. According to the FRANz manual, marker sets are not considered powerful if these cumulative exclusion probabilities are less than 0.95, indicating the probability  a random pair of individuals in the population has a 5% chance of having a genotype pair compatible to an offspring genotype. Since nearly all of our probabilities are 1, we can be confident in the power of our 298 amplicons to make parent-offspring assignments.  

## Data import and overview

  * Read in the following data files:  
    1) "parentage.csv" file for parentage assignments produced by *FRANz*  
    2) paired genotype and OceanAK data (otolith reads, some field data that were saved by `genepop2franz.GCL` in "1_QA"), and  
    3) paired StreamSpecimens contractor data (gill condition, preyed upon, etc.) and `riverdist` data (stream distance)

```{r data_import, echo=FALSE, warning=FALSE, message=FALSE}
parentage_14_16 <- readr::read_csv("~/../Desktop/Local_PWS_pinks/Franz/All_Streams_14_16_develop/results/parentage.csv")  # read_csv("../../Franz/All_Streams_14_16_develop/results/parentage.csv") 
paired_14_16 <- readr::read_csv("../Franz/All_Streams_14_16_develop_postQA_OceanAK_paired_2014_2016_HOGAN_STOCK_GILMOUR_PADDY_ERB.csv")
stream_specimens_riverdist <- readr::read_csv("~/../Desktop/Local_PWS_pinks/GIS/stream_specimens_riverdist_all_streams_2013_2020.csv")  # read_csv("../GIS/R/all_streams/stream_specimens_riverdist_all_streams_2013_2020.csv")
```

  * Plot a histogram of *FRANz* parentage posterior probabilities to show strength of assignments

```{r FRANz_posterior_plot, echo=FALSE, warning=FALSE, message=FALSE}
# first, we establish colorblindness friendly palettes
cbPalette1 <- c("#0072b2", "#d55e00", "#F0E442", "#CC79A7") # blue, orange, yellow, and pink
cbPalette2 <- c("#CC79A7", "#0072b2") # pink and blue for natural- and hatchery-origin

# plot the posteriors
parentage_14_16  %>% 
  dplyr::filter(!base::is.na(`Parent 1`)) %>% 
  ggplot2::ggplot(ggplot2::aes(x = Posterior)) +
  ggplot2::geom_histogram(breaks = seq(0, 1, 0.01), colour = "black") +
  ggplot2::theme_bw() +
  ggplot2::labs(x = "Posterior Probability",
                y = "Count") +
  ggplot2::ggtitle("Histogram of FRANz posterior probabilities for parental assignments")
```

**Results:** Almost all parental assignments have a posterior probability of 1, which is very robust.  

## Subsetting paired genetic/field data

### Parentage

Filter parentage data from *FRANz* to only keep assignments with a posterior probability > 0.9, make tidy/tall (one row per parent-offspring assignment).
```{r filter_parentage_data, echo=FALSE, warning=FALSE, message=FALSE}
# Filter for posterior > 0.9 + make tidy relative to assignment (1 row per parentage assignment)
(
  parentage_14_16_filter <- parentage_14_16 %>%
    dplyr::filter(Posterior > 0.9) %>%
    dplyr::select(Offspring, `Parent 1`, `Parent 2`) %>%
    tidyr::pivot_longer(
      names_to = "Parent",
      values_to = "Parent_ID",
      cols = -Offspring
    ) %>%
    dplyr::filter(!is.na(Parent_ID))
)
```

### OceanAK

The file containing paired genotype and OceanAK data has a lot of information we do not need at this time (e.g. genotypes for each marker). We pull out only the columns that contain identifying information for each individual.

First view all the non-genotype columns to see what we want to retain.
```{r view_oceanak_paired_data, echo=FALSE, warning=FALSE, message=FALSE}
# Find the non-genotype columns
paired_14_16 %>% 
  dplyr::select(-tidyselect::starts_with("Ogo_RAD")) %>% 
  utils::head()
```

Remove genotype columns, rename, and reformat others.
```{r subset_oceanak_paired_data, echo=FALSE, warning=FALSE, message=FALSE}
# Filter for non-genotype columns
(
  paired_14_16_filter <- paired_14_16 %>%
    dplyr::select(
      franz_id,
      SILLY,
      `Fish ID`,
      `DNA Tray Code`,
      `DNA Tray Well Code`,
      `Location Code`,
      `Sample Year`,
      `Sample Date`,
      SEX,
      `Length Mm`,
      `Otolith Mark Present`,
      `Otolith Mark ID`
    ) %>%
    dplyr::rename(
      silly = SILLY,
      fish_id = "Fish ID",
      dna_tray_code = "DNA Tray Code",
      dna_tray_well_code = "DNA Tray Well Code",
      year = "Sample Year",
      length = "Length Mm",
      otolith_mark_present = "Otolith Mark Present",
      otolith_mark_id = "Otolith Mark ID"
    ) %>%
    dplyr::mutate(
      stream = stringr::str_remove(string = `Location Code`, pattern = " Creek"),
      date = lubridate::ymd(`Sample Date`),
      DOY = lubridate::yday(date),  # day of year
      sex = dplyr::case_when(SEX == "M" ~ "Male",
                             SEX == "F" ~ "Female"),
      origin = dplyr::case_when(
        otolith_mark_present == "NO" ~ "Natural",
        otolith_mark_present == "YES" ~ "Hatchery"
      )  # add origin variable
    ) %>%
    dplyr::mutate(origin = base::factor(origin, c(
      "Natural", "Hatchery"
    ))) %>%  # make factor to ensure hatchery != red
    tidyr::unite(
      col = "sample",
      c("dna_tray_code", "dna_tray_well_code"),
      sep = "_",
      remove = FALSE
    ) %>%
    dplyr::select(
      franz_id,
      stream,
      year,
      origin,
      sex,
      date,
      DOY,
      length,
      otolith_mark_present,
      otolith_mark_id,
      silly,
      fish_id,
      sample,
      dna_tray_code,
      dna_tray_well_code
    )
)
```

### Stream Specimens + `riverdist`

The file containing the ancillary contractor data that is not in *OceanAK* + our derived `riverdist` location data.

First view all the columns to see what we want to retain.
```{r view_stream_specimens_riverdist_data, echo=FALSE, warning=FALSE, message=FALSE}
stream_specimens_riverdist %>% 
  utils::head()
```

Join *stream_specimens_riverdist* with *OceanAK* paired data, rename, and reformat columns.
```{r subset_stream_specimens_riverdist_paired_data, echo=FALSE, warning=FALSE, message=FALSE}
(
  paired_14_16_filter <- paired_14_16_filter %>%
    dplyr::left_join(stream_specimens_riverdist, by = c("sample" = "Sample")) %>%  # join based on DWP_well
    dplyr::select(-ADFGStreamCode) %>%
    dplyr::rename(
      stream_trib = StreamName,
      spawning_state = SpawningState,
      pre_spawn = PreSpawn,
      partial_spawn = PartialSpawner,
      preyed_upon = PreyedUpon,
      latitude = Latitude,
      longitude = Longitude,
      distance_mouth = mouthdist,
      distance_tide = dist2tide,
      high_tide = hitide
    ) %>%
    dplyr::mutate(
      intertidal = dplyr::case_when(
        distance_tide <= 0 ~ "Intertidal",
        distance_tide > 0 ~ "Upstream",
        is.na(distance_tide) ~  NA_character_
      )  # create intertidal
    ) %>%
    dplyr::select(
      franz_id,
      stream,
      year,
      origin,
      sex,
      date,
      DOY,
      length,
      distance_mouth,
      intertidal,
      distance_tide,
      tidyselect::everything()
    )
)
```

Save all paired data.
```{r save_paired_filter}
readr::write_csv(paired_14_16_filter, "all_streams_paired_14_16_filter.csv")
```

Clean up environment to free up memory.
```{r}
base::rm(paired_14_16, stream_specimens_riverdist, parentage_14_16)
```

## Sample sizes

  * Quick look at sample sizes for potential parents (2014)

```{r sample_sizes_parents, echo=FALSE, warning=FALSE, message=FALSE}
paired_14_16_filter %>% 
  dplyr::filter(year == 2014) %>%  # filter for parent year
  dplyr::count(stream, origin) %>% 
  tidyr::pivot_wider(names_from = origin, values_from = n, values_fill = 0)
```

  * Quick look at sample sizes for potential offspring (2016)

```{r sample_sizes_offspring, echo=FALSE, warning=FALSE, message=FALSE}
paired_14_16_filter %>% 
  dplyr::filter(year == 2016) %>%  # filter for parent year
  dplyr::count(stream)
```

  * Sample size plots of potential parents and potential offspring collected by day for each stream

```{r sample_sizes_plot, echo=FALSE, warning=FALSE, message=FALSE}
sample_size_plot <-
  function(indata = paired_XX_XX_filter, title = "Stream Year-Year") {
    base::sapply(base::unique(indata$stream), function(x) {
      indata %>%
        dplyr::filter(stream == x) %>%
        ggplot2::ggplot(ggplot2::aes(x = DOY, fill = origin)) +
        ggplot2::geom_bar(colour = "black") +  # group = interaction(DOY, origin))
        ggplot2::scale_x_continuous(breaks = seq(180, 320, by = 5),
                           labels = format(x = (
                             as.Date("2013-12-31") + seq(180, 320, by = 5)
                           ), "%b %d")) +
        ggplot2::facet_grid(year ~ stream) +
        ggplot2::geom_hline(yintercept = 0, colour = "black") +
        ggplot2::labs(title = title, 
                      fill = "Origin",
                      x = "Sample Date",
                      y = "Number of Samples") +
        ggplot2::theme_bw() +
        ggplot2::theme(text = element_text(size = 15),
              axis.text.x = element_text(angle = 90)) +
        ggplot2::scale_fill_manual(values = cbPalette2)
    }, simplify = FALSE)
  }

sample_size_plot(indata = paired_14_16_filter, title = "All Streams 2014-2016")
```

**NOTE** `NA` origin fish in 2016 (offspring) for Erb, Gilmour, and Paddy are due to the GOD event.

# **Basic Statistics**

## Joining parentage with subsetted paired data

Here, we joined parentage data from *FRANz* with individual paired data so that we can match data to each offspring and parent. For this dataset **one row per parent-offspring assignment**. 

**Note** that any column ending in `_off` refers to offspring and `_par` refers to parent. 
```{r join_parentage_and_paired_objects, echo=FALSE, warning=FALSE, message=FALSE}
# Creating a single, "tidy" object where each row is a parent-offspring relationship
# Offspring with 2 parents have 2 rows
# _off data is offspring, _par data is parents
(
  parents_paired_14_16 <- parentage_14_16_filter %>%
    dplyr::left_join(paired_14_16_filter, by = c("Offspring" = "franz_id")) %>%
    dplyr::left_join(
      paired_14_16_filter,
      by = c("Parent_ID" = "franz_id"),
      suffix = c("_off", "_par")
    ) %>% 
    dplyr::rename(offspring_id = Offspring,
                  parent = Parent,
                  parent_id = Parent_ID)
)

readr::write_csv(x = parents_paired_14_16,
                 file = "all_streams_parents_paired_14_16.csv")
```

## Parentage sample sizes

  * Number of single-parent offspring (dyad) and two-parent offspring (triad) assignments for each stream

```{r n_dyads_triads}
parents_paired_14_16 %>% 
  dplyr::count(stream_par, parent) %>% 
  tidyr::pivot_wider(names_from = parent, values_from = n)
```

  * Percent of offspring sampled that were assigned parents (from any stream) for each stream

```{r}
n_off <- paired_14_16_filter %>%
  dplyr::filter(year == 2016) %>%  # filter for parent year
  dplyr::count(stream)

n_off_assigned <- parents_paired_14_16 %>%
  dplyr::filter(parent == "Parent 1") %>% 
  dplyr::count(stream_off)  # accounts for offspring straying among streams

dplyr::left_join(n_off,
                 n_off_assigned,
                 by = c("stream" = "stream_off"),
                 suffix = c("_samp", "_assign")) %>%
  dplyr::mutate(percent_off_assign = base::round(n_assign / n_samp * 100, 1)) %>% 
  dplyr::select(stream, percent_off_assign)

rm(n_off, n_off_assigned)
```

  * Number of offspring (from any stream) assigned by parent origin for each stream

```{r n_offspring_by_origin}
parents_paired_14_16 %>% 
  dplyr::count(stream_par, origin_par) %>% 
  tidyr::pivot_wider(names_from = origin_par, values_from = n)
```

  * Number of distinct, successful (assigned offspring) parents by origin for each stream

```{r}
parents_paired_14_16 %>% 
  dplyr::distinct(parent_id, stream_par, origin_par) %>% 
  dplyr::count(stream_par, origin_par) %>% 
  tidyr::pivot_wider(names_from = origin_par, values_from = n)
```

  * Number of distinct, successful (assigned offspring) hatchery-origin parents by hatchery code for each stream

```{r}
parents_paired_14_16 %>% 
  dplyr::filter(origin_par == "Hatchery") %>% 
  dplyr::distinct(parent_id, stream_par, otolith_mark_id_par) %>% 
  dplyr::count(stream_par, otolith_mark_id_par) %>% 
  tidyr::pivot_wider(names_from = otolith_mark_id_par, values_from = n)
```

**Results:** Most offspring were only assigned to 1 parent (dyads), but there were a decent amount assigned to 2 parents (triads). Offspring assignment rates ranged from a low of **12.1%** in Hogan to a high of **38.6%** in Erb. Interestingly, Stockdale and Gilmour (on Montague Island) mostly receive strays from AFK, Hogan receives a mix of AFK (most common), CCH, and WNH, and Paddy and Erb recieve most of their strays from WNH, followed by AFK, CCH, and a few SGH.

## Proportion test

We performed a chi-square test on the data to naively determine whether the proportions of offspring assigned to hatchery- and natural-origin parents significantly differ from the proportions of hatchery- and natural-origin parents sampled. 

**Note** that for this analysis, the data were not divided out by sex, so offspring from triads are double counted. 
```{r chi_square_test, echo=FALSE, warning=FALSE, message=FALSE}
# How many potential spawners from each origin?
spawners_14 <- paired_14_16_filter %>%
  dplyr::filter(year == 2014) %>%  # filter for parent year
  dplyr::count(stream, origin) %>%
  dplyr::mutate(generation = "Parents")

# How many offspring from each origin?
offspring_16 <- parents_paired_14_16 %>%
  dplyr::count(stream_par, origin_par) %>%
  dplyr::rename(origin = origin_par,
                stream = stream_par) %>%
  dplyr::mutate(generation = "Offspring")

# Make tidy and spread
(
  spawners_and_offspring_14_16 <-
    dplyr::bind_rows(spawners_14, offspring_16) %>%
    dplyr::arrange(stream, origin) %>%
    tidyr::pivot_wider(names_from = generation, values_from = n)
)

rm(spawners_14, offspring_16)  # keep it clean!

# Run chisq.test by stream
spawners_and_offspring_14_16 %>%
  dplyr::nest_by(stream) %>%
  dplyr::mutate(model = list(stats::chisq.test(x = data[,-1]))) %>%
  dplyr::summarise(
    chisq = model$statistic,
    df = model$parameter,
    p_value = model$p.value,
    method = model$method,
    .groups = "keep"
  ) %>%
  dplyr::mutate(signif = dplyr::case_when(p_value <= 0.05 ~ TRUE,
                                          p_value > 0.05 ~ FALSE)) %>%
  dplyr::select(stream, chisq, df, p_value, signif, method)
```

**Results:** All streams, except for Gilmour, showed a significant difference in the proportions of offspring assigned to hatchery- and natural-origin parents relative to the proportions of potential parents sampled, indicating an under-representation of offspring assigning to hatchery-origin parents. 

# **Reproductive Success (RS)**

## Single parent-offspring pairs (dyads)

Here, we calculate family size for parents of both sexes. We also plot two sets of histograms of the proportion of parents with a given family size by sex (number of offspring assigned to a female parent or a male parent) and origin. Next, we calculate sex- and origin-specific mean reproductive success (RS; table below and vertical lines in second set of histograms) and relative reproductive success (RRS) with 95% CIs. For both RS and RRS metrics, we include sampled fish from the parental generation to which offspring were not assigned in addition to known parents (zeroes).

### RS distribution for successful parents (no zeroes)

This first plot does **not** include zeroes, of which there will be many, but it provides better resolution among successful parents, especially for visualizing max family size.
```{r family_size_by_sex_without_zeros, echo=FALSE, warning=FALSE, message=FALSE, fig.height=10}
# Plot histogram of proportion of successful parents with a given family size
parents_paired_14_16 %>% 
  dplyr::count(stream_par, parent_id, origin_par, sex_par) %>% 
  dplyr::count(stream_par, sex_par, origin_par, n, name = "n_par") %>% 
  dplyr::group_by(stream_par, sex_par, origin_par) %>% 
  dplyr::mutate(p = n_par / sum(n_par)) %>% 
  ggplot2::ggplot(aes(x = n, y = p, fill = origin_par)) +
  ggplot2::geom_col(position = position_dodge2(preserve="single"), colour = "black") +
  ggplot2::scale_y_continuous(breaks = scales::pretty_breaks()) +
  ggplot2::scale_x_continuous(breaks = scales::pretty_breaks()) +
  ggplot2::facet_grid(stream_par ~ sex_par) +
  ggplot2::labs(title="Distribution of Family Size by Successful Parents by Sex",
                fill = "Parent: Origin",
                x = "Number of Offspring",
                y = "Proportion of Parents") +
  ggplot2::scale_fill_manual(values = cbPalette2) +
  ggplot2::theme_bw()
```

### RS for all parents (including zeros)

Here, we transform the data to **one row per parent** with `n` = number of offspring assigned, and include all potential parents (including those assigned zero offspring). 
```{r paired_filter_parents, echo=FALSE, warning=FALSE, message=FALSE}
# Transform to one row per parent with n = number of offspring produced
(
  paired_14_16_filter_parents <- paired_14_16_filter %>%
    dplyr::filter(year == "2014") %>%
    dplyr::left_join(
      x = .,
      y = dplyr::count(parents_paired_14_16, parent_id),
      by = c("franz_id" = "parent_id")
    ) %>% 
    dplyr::mutate(n = tidyr::replace_na(data = n, replace = 0)) %>% 
    dplyr::select(franz_id, n, tidyselect::everything())
)

write_csv(x = paired_14_16_filter_parents, file = "all_streams_paired_14_16_filter_parents.csv")
```

  * RS including sampled fish from the parental generation to which offspring were not assigned.

```{r calculate_RS, echo=FALSE, warning=FALSE, message=FALSE}
# Mean RS, including zeroes
rs_14_16_0 <- paired_14_16_filter_parents %>%
  dplyr::group_by(stream, origin, sex) %>% 
  dplyr::summarise(RS = mean(n, na.rm = TRUE), .groups = "drop")

rs_14_16_0 %>%
  tidyr::pivot_wider(names_from = origin, values_from = RS, names_prefix = "RS_") %>% 
  dplyr::mutate(RRS = RS_Hatchery / RS_Natural) %>% 
  dplyr::select(stream, sex, RS_Hatchery, RS_Natural, RRS) %>% 
  dplyr::mutate(dplyr::across(where(is.numeric), round, 2))
```

### RS distribution for all parents (including zeroes)

This plot **does** include zeroes.
```{r family_size_by_sex_with_zeros, echo=FALSE, warning=FALSE, message=FALSE, fig.height=10}
# Plot histogram of proportion of all parents with a given family size
paired_14_16_filter_parents %>% 
  dplyr::count(stream, sex, origin, n, name = "n_par") %>% 
  dplyr::group_by(stream, sex, origin) %>% 
  dplyr::mutate(p = n_par / sum(n_par)) %>% 
  ggplot2::ggplot(aes(x = n, y = p, fill = origin)) +
  ggplot2::geom_col(position = position_dodge2(preserve="single"), colour = "black") +
  ggplot2::scale_y_continuous(breaks = scales::pretty_breaks()) +
  ggplot2::scale_x_continuous(breaks = scales::pretty_breaks()) +
  ggplot2::facet_grid(stream ~ sex) +
  ggplot2::labs(title="Distribution of Family Size by All Parents by Sex",
                fill = "Parent: Origin",
                x = "Number of Offspring",
                y = "Proportion of Parents") +
  ggplot2::scale_fill_manual(values = cbPalette2) +
  ggplot2::theme_bw()
```

**Results:** RS distributions are highly skewed, similar to a negative binomial. In the histograms, note the large number of potential parents assigned no offspring (RS = 0) that were absent from the family size plots above, which only considered successful parents (RS > 0).

### Relative reproductive success (RRS)

#### *Calculate RRS*

Caclulcate RRS by stream and sex.
```{r calculate RRS}
rs_14_16_0 %>%
  tidyr::pivot_wider(names_from = origin, values_from = RS, names_prefix = "RS_") %>% 
  dplyr::mutate(RRS = RS_Hatchery / RS_Natural) %>% 
  dplyr::select(stream, sex, RRS) %>% 
  dplyr::mutate(dplyr::across(where(is.numeric), round, 2)) %>% 
  tidyr::pivot_wider(names_from = sex, values_from = RRS)
```

**Results:** RRS estimates are < 1 for all streams, although some estimates are likely not significantly < 1.

#### *Test for significant differences in RRS*

Next, we test for significant differences in RS between hatchery- and natural-origin fish. This is equivalent to testing if RRS < 1. We perform two different statistical tests on the results in the top panel, including

  1. a non-parametric permutation test (aka randomization test) and
  2. a parametric negative binomial GLM (with no additional covariates).

P-values are presented for each statistical test.

##### By sex

We'll test for difference separately for each sex (dyad data).
```{r RRS_statistical_testing_by_sex}
paired_14_16_filter_parents %>%
  dplyr::nest_by(stream, sex) %>%
  dplyr::mutate(permutation = list(
    coin::oneway_test(
      n ~ origin,
      data = data,
      distribution = coin::approximate(nresample = 10000),
      alternative = "two.sided"  # for a one-sided test use "greater"
    )
  ),
  glm_nb = list(MASS::glm.nb(
    n ~ origin,
    data = data,
    init.theta = 1,
    link = log
  ))) %>%
  dplyr::summarise(permutation_p_value = as.numeric(coin::pvalue(permutation)),
                   glm_nb_p_value = summary(glm_nb)$coefficients["originHatchery", "Pr(>|z|)"],
                   .groups = "drop") %>% 
  dplyr::mutate(dplyr::across(where(is.numeric), round, 4))
```

**Results:** There are significant differences in RRS for females in all streams except Gilmour, but only in Erb and Stockdale for males. 

##### Both sexes combined

...and again with both sexes together (offspring in triads are double counted).
```{r RRS_statistical_testing_by_stream}
paired_14_16_filter_parents %>%
  dplyr::nest_by(stream) %>%
  dplyr::mutate(permutation = list(
    coin::oneway_test(
      n ~ origin,
      data = data,
      distribution = coin::approximate(nresample = 10000),
      alternative = "two.sided"  # for a one-sided test use "greater"
    )
  ),
  glm_nb = list(MASS::glm.nb(
    n ~ origin,
    data = data,
    init.theta = 1,
    link = log
  ))) %>%
  dplyr::summarise(permutation_p_value = as.numeric(coin::pvalue(permutation)),
                   glm_nb_p_value = summary(glm_nb)$coefficients["originHatchery", "Pr(>|z|)"],
                   .groups = "drop") %>% 
  dplyr::mutate(dplyr::across(where(is.numeric), round, 4))
```

**Results:** There are significant differences in RRS for all streams except Gilmour when we ignore sex-specific differences. 

#### *RRS plus 95% CIs for females and males*

We calculated 95% CIs for RRS estimated above, based on [Kalinowski and Taper (2005)](http://www.nrcresearchpress.com/doi/10.1139/f04-239), a maximum likelihood estimate based on [Hinrichsen (2003)](https://cdnsciencepub.com/doi/10.1139/f03-070). This method has been used in other peer reviewed papers, such as [Ford et al. (2016)](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0164801).

Create function.
```{r RRS_confidence_intervals_function, echo=FALSE, warning=FALSE, message=FALSE}
rrs_ci_kalinowski <- function(n_h_off, n_w_off, n_h_par, n_w_par, alpha = .05) {
    
    chi_alpha <- stats::qchisq(p = (1 - alpha), df = 1)
    n_off <- sum(c(n_h_off, n_w_off))
    n_par <- sum(c(n_h_par, n_w_par))
    
    rs_h <- n_h_off / n_h_par
    rs_w <- n_w_off / n_w_par
    
    p_h_par <- n_h_par / n_par
    p_w_par <- n_w_par / n_par
    
    rrs_h <- rs_h / rs_w
    rrs_w <- rs_w / rs_w
    rrs_avg <- (rrs_h * p_h_par) + (rrs_w * p_w_par)
    
    rrs_ml <-
      (n_h_off * log(p_h_par * rrs_h / rrs_avg)) + (n_w_off * log(p_w_par * rrs_w / rrs_avg))
    
    xi_dist <-
      bind_rows(lapply(seq(0.01, 5, by = 0.01), function(rrs_h_xi) {
        rrs_avg_xi <- (rrs_h_xi * p_h_par) + (rrs_w * p_w_par)
        tibble(
          rrs_crit = rrs_h_xi,
          logl = (n_h_off * log(p_h_par * rrs_h_xi / rrs_avg_xi)) + (n_w_off * log(p_w_par * rrs_w / rrs_avg_xi)) - (rrs_ml - chi_alpha / 2)
        )
      }))
    
    rrs_min <- xi_dist %>%
      mutate(abs_logl = abs(logl)) %>%
      filter(rrs_crit < rrs_h) %>%
      top_n(-1, abs_logl) %>%
      pull(rrs_crit)
    
    rrs_max <- xi_dist %>%
      mutate(abs_logl = abs(logl)) %>%
      filter(rrs_crit > rrs_h) %>%
      top_n(-1, abs_logl) %>%
      pull(rrs_crit)
    
    # xi_plot <- xi_dist %>%
    #   ggplot(aes(x = rrs_crit, y = logl)) +
    #   geom_line() +
    #   geom_hline(yintercept = 0, colour = "red", lwd = 2) +
    #   geom_vline(xintercept = c(rrs_h, rrs_min, rrs_max), colour = "blue") +
    #   ylim(c(-5, 5)) +
    #   xlim(c(0, 2)) +
    #   ylab("Log Likelihood - Chi Sq Value") +
    #   annotate("text", x = rrs_h + 0.1, y = xi_dist %>% filter(rrs_crit == xi_dist$rrs_crit[which.min(abs(xi_dist$rrs_crit  - rrs_h))]) %>% pull(logl) + 0.4, label = round(rrs_h, 2)) +
    #   annotate("text", x = rrs_min - 0.1, y = xi_dist %>% filter(rrs_crit == rrs_min) %>% pull(logl) + 0.4, label = rrs_min) +
    #   annotate("text", x = rrs_max + 0.1, y = xi_dist %>% filter(rrs_crit == rrs_max) %>% pull(logl) + 0.4, label = rrs_max)
    #
    # print(xi_plot)
    return(c(rrs_min, rrs_h, rrs_max))
  }
```

Calculate RRS with 95% CI's
```{r RRS_confidence_intervals}
paired_14_16_filter_parents %>%
  dplyr::rename(n_off = n) %>%
  dplyr::group_by(stream, sex, origin) %>%
  dplyr::summarise(n_par = dplyr::n(),
                   n_off = sum(n_off),
                   .groups = "drop") %>%
  tidyr::pivot_wider(names_from = origin, values_from = c(n_par, n_off)) %>%
  dplyr::rename(
    n_h_off = n_off_Hatchery,
    n_w_off = n_off_Natural,
    n_h_par = n_par_Hatchery,
    n_w_par = n_par_Natural
  ) %>%
  dplyr::nest_by(stream, sex) %>%
  dplyr::mutate(rrs_cis = list(
    rrs_ci_kalinowski(
      n_h_off = data$n_h_off,
      n_w_off = data$n_w_off,
      n_h_par = data$n_h_par,
      n_w_par = data$n_w_par
    )
  )) %>%
  dplyr::summarise(
    rrs_lower = rrs_cis[1],
    rrs = rrs_cis[2],
    rrs_upper = rrs_cis[3],
    .groups = "drop"
  ) %>%
  dplyr::mutate(dplyr::across(where(is.numeric), round, 2))
```

**Results:** RRS estimates are significant (upper 95% CI does not contain 1) for all streams and sexes except for Gilmour females and Paddy males.

### RS by field data

Now that we've calculated RRS, we can look into the relationship between RS and some of our field data (date, length, location, etc.).

#### *RS by sample date*

View how RS varies by parent sample date across the season.

**NOTE** the y-axis varies among streams to facilitate visualizing patterns.
```{r RS_by_sample_date, echo=FALSE, warning=FALSE, message=FALSE, fig.height=10}
# Females and males separated
paired_14_16_filter_parents %>%
  ggplot2::ggplot(aes(x = date, y = n, fill = origin)) +
  ggplot2::geom_hline(yintercept = 0, color = "grey50") +
  ggplot2::geom_jitter(
    height = 0,
    size = 4,
    shape = 21,
    color = "black",
    alpha = 0.5
  ) +
  ggplot2::geom_smooth(
    method =  "loess",
    formula = 'y ~ x',
    color = "black",
    size = 1,
    alpha = 0.7
  ) +
  ggplot2::facet_grid(stream ~ sex, scales = "free_y") +
  ggplot2::labs(title = "Reproductive Success by Parental Sample Date and Sex",
                fill = "Parent: Origin",
                x = "Parental Sample Date",
                y = "Reproductive Success") +
  ggplot2::theme_bw() +
  # ggplot2::theme(panel.grid.minor = element_blank()) +
  ggplot2::scale_fill_manual(values = cbPalette2)
```

**Results:** Trends vary by stream, but there is pretty clear separation in RS between hatchery- and natural-origin fish regardless of parent sample date.

#### *RS by body length*

View how RS varies by parent body length (MEH).

**NOTE** the y-axis varies among streams to facilitate visualizing patterns.
```{r RS_by_body_length, echo=FALSE, warning=FALSE, message=FALSE, fig.height=10}
# Females and males separated
paired_14_16_filter_parents %>%
  dplyr::filter(length > 300) %>%  # remove outlier from Stockdale female
  ggplot2::ggplot(aes(x = length, y = n, fill = origin)) +
  ggplot2::geom_hline(yintercept = 0, color = "grey50") +
  ggplot2::geom_jitter(
    height = 0,
    size = 4,
    shape = 21,
    color = "black",
    alpha = 0.5
  ) +
  ggplot2::geom_smooth(
    method =  "loess",
    formula = 'y ~ x',
    color = "black",
    size = 1,
    alpha = 0.7
  ) +
  ggplot2::facet_grid(stream ~ sex, scales = "free_y") +
  ggplot2::labs(title = "Reproductive Success by Parental Body Length and Sex",
                fill = "Parent: Origin",
                x = "Parental Body Length (mm)",
                y = "Reproductive Success") +
  ggplot2::theme_bw() +
  # ggplot2::theme(panel.grid.minor = element_blank()) +
  ggplot2::scale_fill_manual(values = cbPalette2)
```

**Results:** Trends vary by stream, but in general, larger fish tend to have higher RS.

#### *RS by stream location*

View how RS varies by parent sample location within the stream (distance from stream mouth in m).

**NOTE** both the x-axis and y-axis vary among streams to facilitate visualizing patterns.

**NOTE** this is a messy plot, will need to figure out how to display this better some other time...tricky because each stream is fairly different in length and some have multiple tributaries (hence the multiple high-tide lines).
```{r RS_by_location, echo=FALSE, warning=FALSE, message=FALSE, fig.height=10}
# Females and males separated
RS_by_location_plots <-
  sapply(unique(paired_14_16_filter_parents$stream), function(x)
  {
    paired_14_16_filter_parents %>%
      filter(stream == x) %>%
      ggplot2::ggplot(aes(x = distance_mouth, y = n, fill = origin)) +
      ggplot2::geom_hline(yintercept = 0, color = "grey50") +
      ggplot2::geom_jitter(
        height = 0,
        size = 4,
        shape = 21,
        color = "black",
        alpha = 0.5
      ) +
      ggplot2::geom_smooth(
        method =  "loess",
        formula = 'y ~ x',
        color = "black",
        size = 1,
        alpha = 0.7
      ) +
      ggplot2::geom_vline(aes(xintercept = high_tide)) +
      ggplot2::facet_grid(stream ~ sex, scales = "free_y") +
      ggplot2::labs(title = "Reproductive Success by Parental Location and Sex",
                    fill = "Parent: Origin",
                    x = "Parental Sample Distance from Stream Mouth (m)",
                    y = "Reproductive Success") +
      ggplot2::theme_bw() +
      ggplot2::theme(title = element_blank(),
                     axis.title.x = element_blank(),
                     axis.title.y = element_blank()) +
      # ggplot2::theme(panel.grid.minor = element_blank()) +
      ggplot2::scale_fill_manual(values = cbPalette2)
  }, simplify = FALSE)



gridExtra::grid.arrange(RS_by_location_plots$Erb,
                        RS_by_location_plots$Gilmour,
                        RS_by_location_plots$Hogan,
                        RS_by_location_plots$Paddy,
                        RS_by_location_plots$Stockdale,
                        nrow = 5,
                        top = "Reproductive Success by Parental Location and Sex",
                        left = "Reproductive Success",
                        bottom = "Parental Sample Distance from Stream Mouth (m)")
```

**Results:** Trends vary by stream, but in general, RS is higher near the intertidal.

#### *RS by intertidal*

View how RS varies by parent sample location within the stream (intertidal or upstream).

**NOTE** the y-axis varies among streams to facilitate visualizing patterns.
```{r RS_by_intertidal, echo=FALSE, warning=FALSE, message=FALSE, fig.height=10}
# Females and males separated
paired_14_16_filter_parents %>%
  dplyr::filter(!is.na(intertidal)) %>% 
  ggplot2::ggplot(aes(x = intertidal, y = n, fill = origin)) +
  ggplot2::geom_hline(yintercept = 0, color = "grey50") +
  ggplot2::geom_boxplot() +
  ggplot2::facet_grid(stream ~ sex, scales = "free_y") +
  ggplot2::labs(title = "Reproductive Success by Parental Body Length and Sex",
                fill = "Parent: Origin",
                x = "Stream Location: Intertidal vs. Upstream",
                y = "Reproductive Success") +
  ggplot2::theme_bw() +
  # ggplot2::theme(panel.grid.minor = element_blank()) +
  ggplot2::scale_fill_manual(values = cbPalette2)
```

**Results:** Trends vary by stream, but in general, RS is higher near the intertidal. Regardless of intertidal/upstream location, RS tends to be higher for natural-origin fish relative to hatchery-origin fish.

#### *RS by river segment*

View how RS varies by parent sample location within the stream (river segment).

**NOTE:** Hogan and Erb only have a single `riverdist` segment, so they are not considered here.

##### Gilmour

```{r RS_by_riverdist_seg_gilmour, echo=FALSE, warning=FALSE, message=FALSE, fig.height=5}
# Females and males separated
paired_14_16_filter_parents %>%
  dplyr::filter(stream == "Gilmour",
                !is.na(riverdist_seg)) %>% 
  dplyr::mutate(river_seg = factor(riverdist_seg)) %>% 
  dplyr::count(river_seg, origin, name = "n_par") %>% 
  tidyr::pivot_wider(names_from = origin, values_from = n_par)


paired_14_16_filter_parents %>%
  dplyr::filter(stream == "Gilmour",
                !is.na(riverdist_seg)) %>% 
  dplyr::mutate(river_seg = factor(riverdist_seg)) %>% 
  ggplot2::ggplot(aes(x = river_seg, y = n, fill = origin)) +
  ggplot2::geom_hline(yintercept = 0, color = "grey50") +
  ggplot2::geom_boxplot() +
  ggplot2::facet_grid(stream ~ sex, scales = "free_y") +
  ggplot2::labs(title = "Reproductive Success by River Segment and Sex: Gilmour",
                fill = "Parent: Origin",
                x = "Riverdist Segment",
                y = "Reproductive Success") +
  ggplot2::theme_bw() +
  # ggplot2::theme(panel.grid.minor = element_blank()) +
  ggplot2::scale_fill_manual(values = cbPalette2)
```

##### Stockdale

```{r RS_by_riverdist_seg_stockdale, echo=FALSE, warning=FALSE, message=FALSE, fig.height=5}
# Females and males separated
paired_14_16_filter_parents %>%
  dplyr::filter(stream == "Stockdale",
                !is.na(riverdist_seg)) %>% 
  dplyr::mutate(river_seg = factor(riverdist_seg)) %>% 
  dplyr::count(river_seg, origin, name = "n_par") %>% 
  tidyr::pivot_wider(names_from = origin, values_from = n_par)


paired_14_16_filter_parents %>%
  dplyr::filter(stream == "Stockdale",
                !is.na(riverdist_seg)) %>% 
  dplyr::mutate(river_seg = factor(riverdist_seg)) %>% 
  ggplot2::ggplot(aes(x = river_seg, y = n, fill = origin)) +
  ggplot2::geom_hline(yintercept = 0, color = "grey50") +
  ggplot2::geom_boxplot() +
  ggplot2::facet_grid(stream ~ sex, scales = "free_y") +
  ggplot2::labs(title = "Reproductive Success by River Segment and Sex: Stockdale",
                fill = "Parent: Origin",
                x = "Riverdist Segment",
                y = "Reproductive Success") +
  ggplot2::theme_bw() +
  # ggplot2::theme(panel.grid.minor = element_blank()) +
  ggplot2::scale_fill_manual(values = cbPalette2)
```

##### Paddy

```{r RS_by_riverdist_seg_paddy, echo=FALSE, warning=FALSE, message=FALSE, fig.height=5}
# Females and males separated
paired_14_16_filter_parents %>%
  dplyr::filter(stream == "Paddy",
                !is.na(riverdist_seg)) %>% 
  dplyr::mutate(river_seg = factor(riverdist_seg)) %>% 
  dplyr::count(river_seg, origin, name = "n_par") %>% 
  tidyr::pivot_wider(names_from = origin, values_from = n_par)


paired_14_16_filter_parents %>%
  dplyr::filter(stream == "Paddy",
                !is.na(riverdist_seg)) %>% 
  dplyr::mutate(river_seg = factor(riverdist_seg)) %>% 
  ggplot2::ggplot(aes(x = river_seg, y = n, fill = origin)) +
  ggplot2::geom_hline(yintercept = 0, color = "grey50") +
  ggplot2::geom_boxplot() +
  ggplot2::facet_grid(stream ~ sex, scales = "free_y") +
  ggplot2::labs(title = "Reproductive Success by River Segment and Sex: Paddy",
                fill = "Parent: Origin",
                x = "Riverdist Segment",
                y = "Reproductive Success") +
  ggplot2::theme_bw() +
  # ggplot2::theme(panel.grid.minor = element_blank()) +
  ggplot2::scale_fill_manual(values = cbPalette2)
```

#### *RS by pre-spawn*

Unfortunately, data on pre-spawn status was not collected in 2014.

#### *RS by partial-spawn*

Unfortunately, data on prartial-spawn status was not collected in 2014.

#### *RS by preyed-upon*

Unfortunately, data on preyed-upon status was not collected in 2014.

## Parent pair-offspring trios (triads)

Because we have numerous individuals assigned two parents, we examined instances of four potential types of crosses. Crosses may be between hatchery fish (HH), between natural fish (NN), and between natural and hatchery fish, with NH indicating a natural-origin mother and hatchery-origin father and HN indicating a hatchery-origin mother and natural-origin father. 

### Cross types observed

Need to reformat data so that we have **one row per offspring**, with both `sire` and `dam` data preserved.
```{r cross_as_new_grouping_variable, echo=FALSE, warning=FALSE, message=FALSE}
# Which offspring have 2 parents?
triads_14_16 <- parents_paired_14_16 %>% 
  dplyr::filter(parent == "Parent 2") %>% 
  dplyr::pull(offspring_id)

(
  parents_paired_14_16_cross <- parents_paired_14_16 %>%
    dplyr::filter(offspring_id %in% triads_14_16) %>%
    dplyr::select(-parent) %>% # drop "Parent 1" and "Parent 2", replace with dam/sire
    dplyr::mutate(
      relationship = dplyr::case_when(sex_par == "Male" ~ "sire",
                                      sex_par == "Female" ~ "dam")
    ) %>%
    tidyr::pivot_wider(
      names_from = relationship,
      values_from = c(parent_id, tidyselect::contains("_par"))
    ) %>%  # pivot based on dam/sire
    dplyr::rename_with(~ base::gsub(
      x = .x,
      pattern = "_par",
      replacement = ""
    )) %>%
    tidyr::unite(
      col = "mating_id",
      c("parent_id_dam", "parent_id_sire"),
      sep = "_",
      remove = FALSE
    ) %>%
    dplyr::mutate(
      cross_type = dplyr::case_when(
        origin_dam == "Natural" & origin_sire == "Natural" ~ "NN",
        origin_dam == "Natural" & origin_sire == "Hatchery" ~ "NH",
        origin_dam == "Hatchery" & origin_sire == "Natural" ~ "HN",
        origin_dam == "Hatchery" & origin_sire == "Hatchery" ~ "HH"
      )
    )
)

rm(triads_14_16)

readr::write_csv(x = parents_paired_14_16_cross, file = "all_streams_parents_paired_14_16_cross.csv")
```

Verify that parents were sampled in the same stream.
```{r parents_from_same_stream}
all(parents_paired_14_16_cross$stream_dam == parents_paired_14_16_cross$stream_sire)
```

### RS for cross types

Great, now need to reformat data so that we have **one row per unique mating**, with both `sire` and `dam` data preserved, count number of offspring.
```{r paired_14_16_filter_cross}
# Join to get 1 row per unique mating with dam/sire data
(
  paired_14_16_filter_cross <- parents_paired_14_16_cross %>%
    dplyr::select(-c(
      offspring_id, tidyselect::contains("_off")
    )) %>%
    dplyr::distinct() %>%  # drop to one row per mating
    dplyr::left_join(x = .,
                     y = dplyr::count(parents_paired_14_16_cross, mating_id),
                     by = "mating_id") %>%  # join in n_offspring
    dplyr::rename(stream = stream_dam,
                  year = year_dam) %>%
    dplyr::select(-c(stream_sire, year_sire)) %>%
    dplyr::select(
      mating_id,
      n,
      cross_type,
      stream,
      year,
      tidyselect::everything()
    )
)

readr::write_csv(x = paired_14_16_filter_cross, file = "all_streams_paired_14_16_filter_cross.csv")
```

**Results:** We have **728** unique matings documented among the five fitness streams for 2014.

Calculate mean RS by stream and cross type
```{r calculate_RS_cross, echo=FALSE, warning=FALSE, message=FALSE}
# Mean RS, including zeroes
rs_14_16_cross <- paired_14_16_filter_cross %>%
  dplyr::group_by(stream, cross_type) %>% 
  dplyr::summarise(RS = mean(n, na.rm = TRUE), .groups = "drop")

rs_14_16_cross %>%
  tidyr::pivot_wider(names_from = cross_type,
                     values_from = RS,
                     names_prefix = "RS_") %>%
  dplyr::mutate(
    RRS_HH = RS_HH / RS_NN,
    RRS_HN = RS_HN / RS_NN,
    RRS_NH = RS_NH / RS_NN
  ) %>%
  dplyr::mutate(dplyr::across(where(is.numeric), round, 2))
```

**Results:** For Erb, Gilmour, and Stockdale, we see that HH crosses have the lowest RRS, with HN and NH crosses intermediate to NN. This is not observed in Hogan or Paddy, however, samples sizes for Hogan are very small, and dyad-RRS in Paddy was non-significant for males.

#### Samples sizes

How many unique matings occurred by cross type and stream?
```{r n_matings by cross}
paired_14_16_filter_cross %>%
  dplyr::count(stream, cross_type, name = "n_mating") %>%
  tidyr::pivot_wider(names_from = cross_type, values_from =  n_mating)
```

**Results:** Sample sizes of familys (matings) by cross type are fairly small, especially in Hogan.

How many offspring where assigned to each cross type and stream?
```{r n_offspring by cross}
paired_14_16_filter_cross %>% 
  dplyr::group_by(stream, cross_type) %>% 
  dplyr::summarise(n = sum(n), .groups = "drop") %>% 
  tidyr::pivot_wider(names_from = cross_type, values_from =  n)
```

### RS distribution for all crosses (no zeroes)

This plot does **not** include zeroes, because we can not infer a cross occurred unless offspring are assigned.
```{r family_size_by_cross, echo=FALSE, warning=FALSE, message=FALSE, fig.height=10}
# Plot histogram of proportion of all parents with a given family size
paired_14_16_filter_cross %>% 
  dplyr::count(stream, cross_type, n, name = "n_mating") %>% 
  dplyr::group_by(stream, cross_type) %>% 
  dplyr::mutate(p = n_mating / sum(n_mating)) %>% 
  ggplot2::ggplot(aes(x = n, y = p, fill = cross_type)) +
  ggplot2::geom_col(position = position_dodge2(preserve="single"), colour = "black") +
  ggplot2::scale_y_continuous(breaks = scales::pretty_breaks()) +
  ggplot2::scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) +
  ggplot2::facet_grid(stream ~ .) +
  ggplot2::labs(title="Distribution of Family Size by Cross Type",
                fill = "Parent: Cross Type",
                x = "Number of Offspring",
                y = "Proportion of Families") +
  ggplot2::scale_fill_manual(values = cbPalette1) +
  ggplot2::theme_bw()
```

### Relative reproductive success (RRS)

#### *Calculate RRS*

Caclulcate RRS by stream and cross type, all relative to NN.
```{r calculate RRS by cross type}
rs_14_16_cross %>%
  tidyr::pivot_wider(names_from = cross_type,
                     values_from = RS,
                     names_prefix = "RS_") %>%
  dplyr::mutate(
    RRS_HH = RS_HH / RS_NN,
    RRS_HN = RS_HN / RS_NN,
    RRS_NH = RS_NH / RS_NN
  ) %>%
  dplyr::select(stream, contains("RRS")) %>%
  dplyr::rename_with( ~ base::gsub(
    x = .x,
    pattern = "RRS_",
    replacement = ""
  )) %>%
  dplyr::mutate(dplyr::across(where(is.numeric), round, 2))
```

**Results:** RRS estimates are < 1 for all streams, although some estimates are likely not significantly < 1.

#### *RRS plus 95% CIs for cross types*

##### HH/NN

Calculate RRS with 95% CI's
```{r RRS_confidence_intervals_by_cross_type_HH}
paired_14_16_filter_cross %>%
  dplyr::filter(cross_type %in% c("HH", "NN")) %>% 
  dplyr::rename(n_off = n) %>%
  dplyr::group_by(stream, cross_type) %>%
  dplyr::summarise(n_fam = dplyr::n(),
                   n_off = sum(n_off),
                   .groups = "drop") %>%
  tidyr::pivot_wider(names_from = cross_type, values_from = c(n_fam, n_off)) %>%
  dplyr::rename(
    n_h_off = n_off_HH,
    n_w_off = n_off_NN,
    n_h_par = n_fam_HH,
    n_w_par = n_fam_NN
  ) %>%
  dplyr::nest_by(stream) %>%
  dplyr::mutate(rrs_cis = list(
    rrs_ci_kalinowski(
      n_h_off = data$n_h_off,
      n_w_off = data$n_w_off,
      n_h_par = data$n_h_par,
      n_w_par = data$n_w_par
    )
  )) %>%
  dplyr::summarise(
    rrs_lower = rrs_cis[1],
    rrs = rrs_cis[2],
    rrs_upper = rrs_cis[3],
    .groups = "drop"
  ) %>%
  dplyr::mutate(dplyr::across(where(is.numeric), round, 2))
```

**Results:** RRS estimates are significant (upper 95% CI does not contain 1) for Erb and Gilmour, with Stockdale really darn close.

##### HN/NN

Calculate RRS with 95% CI's
```{r RRS_confidence_intervals_by_cross_type_HN}
paired_14_16_filter_cross %>%
  dplyr::filter(cross_type %in% c("HN", "NN")) %>% 
  dplyr::rename(n_off = n) %>%
  dplyr::group_by(stream, cross_type) %>%
  dplyr::summarise(n_fam = dplyr::n(),
                   n_off = sum(n_off),
                   .groups = "drop") %>%
  tidyr::pivot_wider(names_from = cross_type, values_from = c(n_fam, n_off)) %>%
  dplyr::rename(
    n_h_off = n_off_HN,
    n_w_off = n_off_NN,
    n_h_par = n_fam_HN,
    n_w_par = n_fam_NN
  ) %>%
  dplyr::nest_by(stream) %>%
  dplyr::mutate(rrs_cis = list(
    rrs_ci_kalinowski(
      n_h_off = data$n_h_off,
      n_w_off = data$n_w_off,
      n_h_par = data$n_h_par,
      n_w_par = data$n_w_par
    )
  )) %>%
  dplyr::summarise(
    rrs_lower = rrs_cis[1],
    rrs = rrs_cis[2],
    rrs_upper = rrs_cis[3],
    .groups = "drop"
  ) %>%
  dplyr::mutate(dplyr::across(where(is.numeric), round, 2))
```

**Results:** RRS estimates are significant (upper 95% CI does not contain 1) only Gilmour.

##### NH/NN

Calculate RRS with 95% CI's
```{r RRS_confidence_intervals_by_cross_type_NH}
paired_14_16_filter_cross %>%
  dplyr::filter(cross_type %in% c("NH", "NN")) %>% 
  dplyr::rename(n_off = n) %>%
  dplyr::group_by(stream, cross_type) %>%
  dplyr::summarise(n_fam = dplyr::n(),
                   n_off = sum(n_off),
                   .groups = "drop") %>%
  tidyr::pivot_wider(names_from = cross_type, values_from = c(n_fam, n_off)) %>%
  dplyr::rename(
    n_h_off = n_off_NH,
    n_w_off = n_off_NN,
    n_h_par = n_fam_NH,
    n_w_par = n_fam_NN
  ) %>%
  dplyr::nest_by(stream) %>%
  dplyr::mutate(rrs_cis = list(
    rrs_ci_kalinowski(
      n_h_off = data$n_h_off,
      n_w_off = data$n_w_off,
      n_h_par = data$n_h_par,
      n_w_par = data$n_w_par
    )
  )) %>%
  dplyr::summarise(
    rrs_lower = rrs_cis[1],
    rrs = rrs_cis[2],
    rrs_upper = rrs_cis[3],
    .groups = "drop"
  ) %>%
  dplyr::mutate(dplyr::across(where(is.numeric), round, 2))
```

**Results:** RRS estimates are not significant (upper 95% CI does not contain 1) for any of the streams.

# **Mating dynamics**

We already verified that all of our matings took place between dams and sires that were sampled in the same streams, but how do the dams and sires differ in terms of sample date and sample location?

## Sire vs. Dam sample date

```{r dam_v_sire_sample_date, fig.height = 10}
paired_14_16_filter_cross %>% 
  ggplot2::ggplot(aes(x = date_dam, y = date_sire, fill = cross_type)) +
  ggplot2::geom_jitter(
    height = 0,
    size = 4,
    shape = 21,
    color = "black",
    alpha = 0.5
  ) +
  geom_abline(intercept = 0, slope = 1) +
  ggplot2::facet_grid(stream ~ ., scales = "fixed") +
  ggplot2::labs(title = "Distribution of Crosses by Dam and Sire Sample Date",
                fill = "Parent: Cross Type",
                x = "Dam Sample Date",
                y = "Sire Sample Date") +
  ggplot2::theme_bw() +
  ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  ggplot2::coord_fixed() +
  # ggplot2::theme(panel.grid.minor = element_blank()) +
  ggplot2::scale_fill_manual(values = cbPalette1)
```

**Results:** Samples dates for dams and sires align fairly well seem believable. In general, dams were sampled slightly later, which makes sense as males typically enter the system first.

## Sire vs. Dam sample location

```{r dam_v_sire_sample_location, fig.height = 10}
paired_14_16_filter_cross %>% 
  ggplot2::ggplot(aes(x = distance_mouth_dam, y = distance_mouth_sire, fill = cross_type)) +
  ggplot2::geom_jitter(
    height = 0,
    size = 4,
    shape = 21,
    color = "black",
    alpha = 0.5
  ) +
  geom_abline(intercept = 0, slope = 1) +
  ggplot2::facet_grid(stream ~ ., scales = "free_y") +
  ggplot2::labs(title = "Distribution of Crosses by Dam and Sire Sample Location",
                fill = "Parent: Cross Type",
                x = "Dam Sample Location",
                y = "Sire Sample Location") +
  ggplot2::theme_bw() +
  ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5)) +
  # ggplot2::theme(panel.grid.minor = element_blank()) +
  ggplot2::scale_fill_manual(values = cbPalette1)
```

**Results:** This is messy, but it looks like sires tended to be sampled further downstream in Hogan and Stockdale.

## Multiple matings

We set out to discover who is mating with whom and when. We know multiple matings occur, but we want to understand whether it's males and/or females that have multiple partners. We thus set out to assess promiscuity within the sexes. We next calculated the number of mates for each known female and male parent (dams and sires).
```{r multiple_matings, echo=FALSE, warning=FALSE, message=FALSE}
# How many dams had multiple sires
dam_promiscuity <- parents_paired_14_16_cross %>% 
  dplyr::group_by(parent_id_dam) %>% 
  dplyr::summarise(n_sires = n_distinct(parent_id_sire)) %>% 
  dplyr::count(n_sires) %>% 
  dplyr::rename(n_mates = n_sires, n_dams = n)

# How many sires had multiple dams
sire_promiscuitiy <- parents_paired_14_16_cross %>% 
  dplyr::group_by(parent_id_sire) %>% 
  dplyr::summarise(n_dams = n_distinct(parent_id_dam)) %>% 
  dplyr::count(n_dams) %>% 
  dplyr::rename(n_mates = n_dams, n_sires = n)

(promiscuity <- dplyr::full_join(dam_promiscuity, sire_promiscuitiy, by = "n_mates"))

rm(dam_promiscuity, sire_promiscuitiy)
```
**Results:** Both dams and sires displayed promiscuity at relatively equal levels. 

# **Investigate natural straying**

How many offspring had parent from each stream?
```{r n_offspring_by_parent_stream}
parents_paired_14_16 %>%
  dplyr::filter(parent == "Parent 1") %>% 
  dplyr::mutate(
    stream_par = base::factor(
      x = stream_par,
      levels = c("Erb", "Paddy", "Hogan", "Gilmour", "Stockdale")
    ),
    stream_off = base::factor(
      x = stream_off,
      levels = c("Erb", "Paddy", "Hogan", "Gilmour", "Stockdale")
    )
  ) %>%
  dplyr::count(stream_par, stream_off) %>%  #, origin.par
  tidyr::pivot_wider(names_from = stream_off, values_from = n)
```

**Results:** Geographic patterns of straying among streams make sense. Paddy and Erb are mainland populations that are fairly close together, and Gilmour and Stockdale are very close together on Montague Island. Hogan definitely seems like an "attractor" stream, receiving strays from all five study streams (and super high pHOS).

Filter for parents that produced strays and determine how many of their offspring strayed.
```{r how_many_strays}
parents_produce_strays <- parents_paired_14_16 %>%
  dplyr::filter(parent == "Parent 1",
                stream_par != stream_off) %>%
  dplyr::distinct(parent_id) %>%
  dplyr::pull()

parents_paired_14_16 %>% 
  dplyr::filter(parent_id %in% parents_produce_strays) %>% 
  dplyr::group_by(parent_id, stream_par, origin_par) %>% 
  dplyr::summarise(n_home = sum(stream_par == stream_off),
                   n_stray = sum(stream_par != stream_off),
                   .groups = "keep") %>% 
  dplyr::mutate(n_off = sum(n_home, n_stray),
                p_stray = n_stray / n_off) 

parents_paired_14_16 %>% 
  dplyr::filter(parent_id %in% parents_produce_strays) %>% 
  dplyr::group_by(parent_id, stream_par, origin_par) %>% 
  dplyr::summarise(n_home = sum(stream_par == stream_off),
                   n_stray = sum(stream_par != stream_off),
                   .groups = "keep") %>% 
  dplyr::mutate(n_off = sum(n_home, n_stray),
                p_stray = n_stray / n_off) %>% 
  dplyr::group_by(stream_par, origin_par) %>% 
  dplyr::summarise(n_stray = sum(n_stray), .groups = "drop") %>% 
  tidyr::pivot_wider(names_from = origin_par, values_from = n_stray)


rm(parents_produce_strays)
```

Compare to how many total offspring assigned back to parents from each stream.
```{r n_offspring_by_origin_total}
parents_paired_14_16 %>% 
  dplyr::count(stream_par, origin_par) %>% 
  tidyr::pivot_wider(names_from = origin_par, values_from = n)
```

**Results:** No obvious influence of parent-origin on propensity of offspring to stray.

# **Grandparentage**

WORK IN PROGRESS - 

We find the parents (2017) that were assigned to grandparents (2015) and determine how many grandoffspring (2019) were assigned to them. We then estimate RRS according to grandparental origin. The set of panels below include:
```{r import_grandparent_data, echo=FALSE, warning=FALSE, message=FALSE}
# Read in data
parents_paired_15_17 <-
  readr::read_csv("stock_parents_paired_15_17.csv") %>%
  dplyr::select(-origin)

paired_17_19_filter_parents <-
  readr::read_csv("Stockdale_paired_17_19_filter_parents.csv")

parentage_paired_17_19 <-
  readr::read_csv("Stockdale_parents_paired_17_19.csv") %>%
  dplyr::select(-origin)
```
  
  1. IDs of the grandoffspring, their parents, and their grandparents
  
```{r gpar_1, echo=FALSE, warning=FALSE, message=FALSE}
(
  gparent_table <- parentage_paired_17_19 %>%
    dplyr::inner_join(
      parents_paired_15_17,
      by = c("Parent_ID" = "Offspring"),
      suffix = c("_17", "_15")
    )
)
```
 
  2. How many grandparents, independent of origin, produced a certain number of grandoffspring
 
```{r gpar_2, echo=FALSE, warning=FALSE, message=FALSE}
(
  gparents1 <- gparent_table %>%
    dplyr::count(Parent_ID_15) %>%
    dplyr::count(n) %>%
    dplyr::rename(n_grandparents = nn, n_grandoffspring = n)
)
```

  3. How many parents produced a certain number of grandoffspring, with a grandparent of a particular origin
  
```{r gpar_3, echo=FALSE, warning=FALSE, message=FALSE}
(
  gparents2 <- paired_17_19_filter_parents %>%
    dplyr::right_join(parents_paired_15_17, by = c("franz_id" = "Offspring")) %>%
    dplyr::count(origin.par, n) %>%
    dplyr::rename(
      Grandparental_origin = origin.par,
      n_parents = nn,
      n_grandoffspring = n
    )
)
```
  
  4. How many of those grandoffspring had a particular number of grandparents assigned to them
  
```{r gpar_4, echo=FALSE, warning=FALSE, message=FALSE}
# Origin (origin.par) and numbers of F0 grandparents, their assigned F1 offspring, and assigned F2 grandoffspring
(
  gparents_origin <- paired_17_19_filter_parents %>%
    dplyr::right_join(parents_paired_15_17, by = c("franz_id" = "Offspring")) %>%
    dplyr::group_by(origin.par) %>%
    dplyr::summarise(
      n_grandparents = length(unique(Parent_ID)),
      n_parents = length(franz_id),
      n_offspring = sum(n, na.rm = TRUE)
    ) %>%
    dplyr::rename(Grandparental_origin = origin.par)
)
```
  
  5. RRS plus 95% CIs based on the summary table
  
```{r gpar_5, echo=FALSE, warning=FALSE, message=FALSE}
rrs_gpar_17_19 <-
  as.data.frame(
    rrs_ci_kalinowski(
      n_h_off = as.integer(gparents_origin[1, 4]),
      n_w_off = as.integer(gparents_origin[2, 4]),
      n_h_par = as.integer(gparents_origin[1, 3]),
      n_w_par = as.integer(gparents_origin[2, 3]),
      alpha = 0.05
    )
  )

colnames(rrs_gpar_17_19) <- c("Stockdale_grandparents_17_19")
rownames(rrs_gpar_17_19) <- c("Lower 95% CL", "RRS", "Upper 95% CL")

rrs_gpar_17_19 %>%
  round(2)
```
  
  6. Origin of the parents and grandparents for each grandoffspring
  
```{r gpar_6, echo=FALSE, warning=FALSE, message=FALSE}
# Offspring (sire and dam generation), grandsire, and grandsire origin
sires_15 <- parents_paired_15_17 %>%
  dplyr::filter(Sex.par == "Male") %>%
  dplyr::rename(Sire = Parent_ID, Sire_origin = origin.par) %>%
  dplyr::select(Offspring, Sire, Sire_origin)

# Offspring (sire and dam generation), granddam, and granddam origin
dams_15 <- parents_paired_15_17 %>%
  dplyr::filter(Sex.par == "Female") %>%
  dplyr::rename(Dam = Parent_ID, Dam_origin = origin.par) %>%
  dplyr::select(Offspring, Dam, Dam_origin)

# Grandsire and granddam data combined
parents_15_17 <- full_join(sires_15, dams_15, by = "Offspring") %>%
  dplyr::arrange(Offspring)

# Grandoffspring, sire, and sire origin
sires_17 <- parentage_paired_17_19 %>%
  dplyr::filter(Sex.par == "Male") %>%
  dplyr::rename(Sire = Parent_ID, Sire_origin = origin.par) %>%
  dplyr::select(Offspring, Sire, Sire_origin)

# Grandoffspring, dam, and dam origin
dams_17 <- parentage_paired_17_19 %>%
  dplyr::filter(Sex.par == "Female") %>%
  dplyr::rename(Dam = Parent_ID, Dam_origin = origin.par) %>%
  dplyr::select(Offspring, Dam, Dam_origin)

# Grandsire, granddam, sire, and dam data combined
(
  grandparentage <-
    full_join(sires_17, dams_17, by = "Offspring") %>%
    dplyr::arrange(Offspring) %>%
    dplyr::left_join(
      parents_15_17,
      by = c("Sire" = "Offspring"),
      suffix = c("", "_paternal")
    ) %>%
    dplyr::left_join(
      parents_15_17,
      by = c("Dam" = "Offspring"),
      suffix = c("", "_maternal")
    ) %>%
    dplyr::group_by(Offspring) %>%
    dplyr::mutate(
      n_par = sum(!is.na(Sire),!is.na(Dam)),
      n_grandparents = sum(
        !is.na(Sire_paternal),
        !is.na(Sire_maternal),
        !is.na(Dam_paternal),
        !is.na(Dam_maternal)
      )
    ) %>%
    dplyr::ungroup() %>%
    dplyr::filter(n_grandparents > 0)
)

readr::write_csv(grandparentage, "Stockdale_17_19_grandparentage.csv")
```
  
  7. Number of grandparents assigned to each grandoffspring
  
```{r gpar_7, echo=FALSE, warning=FALSE, message=FALSE}
(
  grandparentage %>%
    dplyr::count(n_grandparents) %>%
    dplyr::rename(n_grandparents_assigned = n_grandparents, n_offpring = n)
)
```

**Results:** A total of **XX** unique hatchery-origin grandparents were assigned to **XX** parents, **XX** of which assigned to **XX** grandoffspring, and **XX** unique natural-origin grandparents assigned to **XX** parents, **XX** of which assigned to **XX** grandoffspring. Each assigned grandparent contributed to **1-XX** grandoffspring. RRS from the parental to grandoffspring generation was **XX**. However, this result requires circumspection and cautious interpretation. It is not a pure RRS estimate because it is based on a fraction of full familial origin/ancestry information. Only one F~1~ parent is known for the majority of grandoffpring; an unknown parent may be of either origin and may have been sampled or unsampled. Compounding that, **XX** grandoffspring had one, **XX** had two, and **one** grandoffspring each had three and four grandparents assigned. Again, any unknown grandparent(s) are of unknown origin.

# **Great Grandparentage**

WORK IN PROGRESS - What are we trying to do here and what can we do here?

```{r import_great_grandparental_data, echo=FALSE, warning=FALSE, message=FALSE}
# Read in data
parents_paired_13_15 <-
  readr::read_csv("stock_parents_paired_13_15.csv") %>%
  dplyr::select(-origin)

parents_paired_15_17 <-
  readr::read_csv("stock_parents_paired_15_17.csv") %>%
  dplyr::select(-origin)

parents_paired_17_19 <-
  readr::read_csv("Stockdale_parents_paired_17_19.csv") %>%
  dplyr::select(-origin)

paired_17_19_filter_parents <-
  readr::read_csv("Stockdale_paired_17_19_filter_parents.csv")

paired_15_17_filter_parents <-
  readr::read_csv("stock_paired_15_17_filter_parents.csv")
```
  
  1. IDs of the great grandoffspring, their parents, their grandparents, and their great grandparents
  
```{r ggpar_1, echo=FALSE, warning=FALSE, message=FALSE}
# Who were the grandoffspring, their parents, and their grandparents?
ggparents_IDs <- parents_paired_15_17 %>%
  dplry::inner_join(
    parents_paired_13_15,
    by = c("Parent_ID" = "Offspring"),
    suffix = c("_15", "_13")
  )

(
  ggparents_table <- parents_paired_17_19 %>%
    dplry::inner_join(
      parents_paired_15_17,
      by = c("Parent_ID" = "Offspring"),
      suffix = c("_17", "_15")
    ) %>% # same as in gparent_table from Grandparentage above
    dplry::inner_join(ggparents_IDs, by = c("Parent_ID_15" = "Parent_ID"))
)
```
 
  2. How many great grandparents, independent of origin, produced a certain number of great grandoffspring
 
```{r ggpar_2, echo=FALSE, warning=FALSE, message=FALSE}
# How many great grandparents, independent of origin, produced a certain number of great grandoffspring
(
  ggparents_ggoffspring <- ggparents_table %>%
    dplry::count(Parent_ID_13) %>%
    dplry::count(n) %>%
    dplry::rename(
      n_greatgrandparents = nn,
      n_greatgrandoffspring = n
    )
)
```

  3. How many of those grandoffspring had a particular number of grandparents assigned to them
  
```{r ggpar_3, echo=FALSE, warning=FALSE, message=FALSE}
# Origin (origin.par.x) and numbers of F0 great grandparents, their assigned F1 offspring, assigned F2 grandoffspring, and assigned F3 great grandoffspring
(
  ggparents_origin <- paired_17_19_filter_parents %>%
    dplry::full_join(parents_paired_15_17, by = c("franz_id" = "Offspring")) %>%
    dplry::right_join(parents_paired_13_15, by = c("Parent_ID" = "Offspring")) %>%
    dplry::group_by(origin.par.y) %>%
    dplry::summarise(
      n_great_grandparents = length(unique(Parent_ID.y)),
      n_grandparents = length(which(!is.na(Parent_ID))),
      n_parents = length(which(!is.na(franz_id))),
      n_offspring = sum(n, na.rm = TRUE)
    ) %>%
    dplry::rename(Great_grandparental_origin = origin.par.y)
)
```

**Results:** We couldn't do much with this remaining data. We found two great grandparents, both natural-origin, each tied to one great grandoffspring.

# **Summary of Results**

## 2014-2016 (Parentage)

1. Almost all exclusion probabilities were equal to 1, which means we can be confident in the ability of our marker set to correctly assign parents to offspring.  
2. 7,988 out of 27,935 offspring were assigned to 2,207 distince parents, for an overall assignment rate of 28.6%.
4. RRS point estimates ranged from 0.29-0.96 for males and 0.34-0.88 for females. RRS estimates were statistically significant (95% CI did not contain 1) for all combinations, except Gilmour-female and Paddy-male.  
5. All four crosses were represented (HH, NH, HN, and NN), but cross type RS relative to the NN were only significantly less than 1 for HH/NN for Erb, Gilmour, and almost Stockdale.  

## 2015-2017-2019 (Grandparentage)

1. A total of 468 unique grandparents were identified that produced 84 grandoffspring, 52 of which had one, 13 of which had two, and one each of which had three and four grandparents assigned.
2. 2017 to 2019 RRS was 1.17 (95% CI [0.59, 2.12]) when taken in light of grandparental origin.

## 2013-2015-2017-2019 (Great grandparentage)

1. 2 natural-origin great grandparents (2013) were assigned to 2 offspring (2019)

```{r}
save.image("2_Parentage_All_Streams_2014_2016_develop_20220212.RData")
```

End